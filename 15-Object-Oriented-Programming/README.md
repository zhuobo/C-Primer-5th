# Object Oriented Programming
## OOP 概述
1. 面向对象程序设计的核心思想是**数据抽象**，**继承**，**动态绑定**。通过数据抽象可以实现接口与实现的分离，使用继承可以定义相似的类型并对其相似关系建模，使用动态绑定（多态）可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。
2. 当使用基类的指针或者引用调用一个虚函数的时候发生动态绑定，具体执行哪个版本的函数由传入的实参决定，在运行时选择执行的函数的版本，因此称为运行时绑定（run-time binding）。
3. 基类应该定义一个虚析构函数，即使这个函数不执行任何操作。
## 基类和派生类
1. 在 C++ 中，基类必须将两种成员函数区分开来，一种是希望子类继承并进行覆盖的函数；另一种是基类希望子类直接继承而不需要改变的函数。对于前者，基类将函数定义为虚函数，使得通过指针或者引用调用虚函数的时候发生运行时动态绑定。一个虚函数在子类中默认也是虚函数。一个函数如果不是虚函数，它的解析发生在编译阶段，而不是运行时。
2. 派生类中含有与其基类对应的组成部分，因此能把派生类对象当成基类对象使用，也能把基类的指针或者引用绑定到派生类对象**基类部分上**。这就意味着当使用基类的引用或者指针的时候，我们不清楚这个引用或者指针所绑定的对象的真实类型。**基类的指针或者引用的静态类型和动态类型可能不一致。** 当有多个基类时，可以当成派生类对象中有多个基类的子对象。
3. 派生类的构造函数：派生类含有基类继承而来的成员，但是派生类不能直接初始化这些成员，必须使用基类的构造函数初始化这些基类部分。
4. 使用关键字 final 防止一个类被继承：

```C++
class Noderived final { /* */ }; // Noderived类不能作为基类被继承
```

5. 当我们用一个派生类对象为一个基类对象初始化或赋值时，只有派生类对象中的基类部分会被拷贝、移动、赋值，它的派生类部分会被忽略掉。

## 虚函数
1. 动态绑定只有通过指针或者引用调用虚函数时才会发生，当通过一个普通类型（非引用非指针）的表达式调用虚函数，在**编译**时就会将调用的虚函数版本确定下来。
2. 当在派生类覆盖某个虚函数时，可以显式使用关键字 virtual 指出这个函数的性质，但是这不是必须的，因为一旦某个函数被声明为虚函数，在所有派生类中它都是虚函数。
3. override 和 final：将函数标记为 override 的意思时我们希望覆盖基类中的虚函数，如果没有覆盖（基类中没有这个虚函数）那么编译器会报错，而将函数标记为 final 的意思是之后任何尝试覆盖这个函数的操作都是错误的。（形参列表后的修饰符包括 const，override，final都是用来修饰函数的）。

## 抽象基类
1. 可以为纯虚函数提供定义，但是定义只能在类的外部，也就是说不能在类的内部为一个 =0 的函数提供定义。
2. 含有纯虚函数的类是抽象基类，抽象基类负责定义接口，而后续的类可以覆盖该接口，不能直接创建一个抽象基类的对象。

## 访问控制与继承
1. protected 成员
    * 和 private 成员相似，protected 成员对于类的用户来说是不可访问的；
    * 和 public 成员相似，protected 成员对于派生类的成员和友元来说是可访问的；
    * 派生类的成员或者友元只能通过派生类对象来访问基类的 protected 成员，派生类对于一个基类对象中的 protected 成员没有任何访问特权。这句话有点拗口：**事实上派生类的成员和友元只能访问派生类自己的基类部分的 protected 成员，而对于普通基类对象中的 protected 成员是没有访问权限的**。

2. public、private、protected继承
    * 某个类对继承而来的成员的访问权限受两个因素影响：一是基类中该成员的访问说明符，二是派生类派生列表中的访问说明符。
    * 派生说明符对于派生类的成员或者友元能否访问其直接基类的成员没有什么影响,对于基类成员的访问权限只与基类中的访问说明符有关。派生访问说明符是为了控制派生类用户对于基类成员的访问权限的。比如 public 继承，说明继承自基类的成员是 public 的，private 继承说明继承自基类的成员是 private 的。

3. 友元和继承
    * 友元关系不能传递，同样也无法继承；

4. 默认的继承保护级别  
    * 使用关键字 class 默认派生类是私有继承，使用关键字 struct 默认派生类是共有继承。class 和 struct 的区别就仅仅是默认的成员访问说明符，以及默认派生访问说明符不同而已，没有其他的不同了！

## 继承中的类作用域

1. 在编译时进行名字查找
    * 一个对象,引用或者指针的静态类型举行了该对象的哪些成员是可见的。比如说一个基类的指针 baseP 绑定到了派生类，那么 baseP 的静态类型就是基类指针，动态类型应该是派生类，能够使用的成员查找范围是从静态类型基类开始查找，而不是动态类型派生类开始查找。
2. 名字冲突与继承
    * 派生类的成员将隐藏同名的基类成员，哪怕具有不同的形参列表。
3. 名字查找先于类型检查
    * 由于首先进行名字查找，只要找到一个同名的成员，编译器就终止查找，然后再进行函数类型检查，如果此时发现形参列表不对，编译器就会报错。
4. 虚函数和作用域
    * 加入派生类和基类的虚函数有不同的形参列表，那么就不能通过基类的引用或者指针调用派生类的虚函数，这是因为派生类的函数会隐藏同名的虚函数，这种情况就导致派生类事实上并没有覆盖虚函数。
5. 通过基类调用隐藏的虚函数
    * 如果派生类没有覆盖虚函数，那么通过绑定到派生类的基类引用或者指针调用虚函数，在运行时会被解析为基类的版本。
6. 覆盖重载的函数

## 构造函数与拷贝控制
1. 虚析构函数
    * 基类应该定义一个虚析构函数，这样能够动态分配继承体系中的对象。
    * 如果基类的析构函数不是虚函数，那么 delete 一个指向派生类对象的基类指针就是未定义的行为，因为不能保证运行正确版本的析构函数（静态类型和动态类型不一致）
2. 合成拷贝控制与继承
    * 
## 容器与继承
1. 在容器中放置（智能）指针而非对象
    * 当使用容器存放继承体系中的对象时，因为容器不允许保存不同类型的元素，因此当把一个派生类放入存储基类的容器，派生类对象的派生部分会被“切掉”，只保留基类部分。
    * 当使用指针的时候，则可以动态的决定到底是基类还是派生类。
    * 
